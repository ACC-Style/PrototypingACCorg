---
layout: arches_content-spaced
name: "Carousel"
position: "JavaScript"
---


<script>
  class InfiniteCarousel {
	constructor(container, options = {}) {
		this.container = container;
		this.track = container.querySelector('.carousel-track');
		this.slides = Array.from(this.track.children);
		this.originalSlides = [...this.slides];
		this.nextBtn = container.querySelector('.carousel-next');
		this.prevBtn = container.querySelector('.carousel-prev');
		this.dotsContainer = container.querySelector('.carousel-dots');
		this.slideTotal = container.dataset.cardcount;

		this.currentIndex = 0;
		this.dots = [];
		this.autoplay = options.autoplay || false;
		this.autoplayDelay = options.autoplayDelay || 3000;
		this.breakpoints = options.breakpoints || { 0: 1 };
		this.autoplayTimer = null;
		this.transitionClass = options.transitionClass || 'transition_4';

		this.handleResize = this.handleResize.bind(this);

		this.container.classList.add('slider-active');
		this.setupCarousel();
		this.updateSlideMetrics();
		this.enable();

		window.addEventListener('resize', this.handleResize);
	}

	setupCarousel() {
		this.visibleSlides = this.getVisibleSlides();
		this.marginOffset = this.getSlideMargins();
		this.container.style.setProperty('--visible-slides', this.visibleSlides);
		this.container.style.setProperty('--margin-offset', this.marginOffset);

		if (this.originalSlides.length <= this.visibleSlides) {
			this.container.querySelector('.carousel-nav').classList.add('display_none');
			this.container.querySelector('.carousel-dots').classList.add('display_none');
			this.updateSlideMetrics();
			this.updatePosition(true);
			return;
		}

		this.track.innerHTML = '';
		this.container.querySelector('.carousel-nav').classList.remove('display_none');
		this.container.querySelector('.carousel-dots').classList.remove('display_none');
		this.dotsContainer.style.display = '';

		this.slides = this.originalSlides.map(slide => slide.cloneNode(true));

		const prependClones = this.slides.slice(-this.visibleSlides).map(slide => slide.cloneNode(true));
		const appendClones = this.slides.slice(0, this.visibleSlides).map(slide => slide.cloneNode(true));

		this.slides = [...prependClones, ...this.slides, ...appendClones];

		this.slides.forEach(slide => {
			slide.classList.add('carousel-slide');
			slide.style.flex = `0 0 calc( (100% / ${this.visibleSlides}) - ${this.marginOffset} )`;
			this.track.appendChild(slide);
		});

		this.currentIndex = this.visibleSlides;

		this.updateSlideMetrics();
		this.setupDots();
		this.updatePosition(true);
	}

	setupDots() {
		this.dotsContainer.innerHTML = '';
		const count = this.originalSlides.length;
		this.dots = [];

		for (let i = 0; i < count; i++) {
			const dot = document.createElement('span');
			dot.addEventListener('click', () => {
				this.currentIndex = this.visibleSlides + i;
				this.updatePosition();
			});
			this.dotsContainer.appendChild(dot);
			this.dots.push(dot);
		}

		this.updateDots();
	}

	updateDots() {
		if (!this.dots || this.dots.length === 0) return;

		const totalDots = this.dots.length;
		let dotIndex = (this.currentIndex - this.visibleSlides) % totalDots;

		if (dotIndex < 0) dotIndex += totalDots;

		this.dots.forEach(dot => dot.classList.remove('active'));
		this.dots[dotIndex].classList.add('active');
	}

	getVisibleSlides() {

		const width = this.container.offsetWidth;
		let slidesToShow = 1;

		for (const bp in this.breakpoints) {
			if (width >= parseInt(bp)) {
				slidesToShow = Math.min(this.breakpoints[bp], this.slideTotal);
			}
		}
		return slidesToShow;
	}

	getSlideMargins() {
		const slide = this.container.querySelector('.carousel-slide');
		const styles = getComputedStyle(slide);
		return (parseInt(styles.marginLeft) + parseInt(styles.marginRight)) || 0;
	}

	updatePosition(skipTransition = false) {
		if (skipTransition) {
			this.track.classList.remove(this.transitionClass);
		} else {
			this.track.classList.add(this.transitionClass);
		}
		const offset = -(this.currentIndex * (this.slideWidth + this.marginOffset));
		this.track.style.transform = `translateX(${offset}px)`;

		this.updateDots();
	}

	updateSlideMetrics() {
		const slide = this.container.querySelector('.carousel-slide');
		this.slideWidth = slide.getBoundingClientRect().width;
	}

	moveNext() {
		this.currentIndex++;
		this.updatePosition();
		this.checkLoopForward();
	}

	movePrev() {
		this.currentIndex--;
		this.updatePosition();
		this.checkLoopBackward();
	}

	checkLoopForward() {
		this.track.addEventListener('transitionend', () => {
			if (this.currentIndex >= this.slides.length - this.visibleSlides) {
				this.track.classList.remove(this.transitionClass);
				this.currentIndex = this.visibleSlides;
				this.updatePosition(true);
			}
		}, { once: true });
	}

	checkLoopBackward() {
		this.track.addEventListener('transitionend', () => {
			if (this.currentIndex < this.visibleSlides) {
				this.track.classList.remove(this.transitionClass);
				this.currentIndex = this.slides.length - this.visibleSlides - 1;
				this.updatePosition(true);
			}
		}, { once: true });
	}

	enable() {
		this.nextBtn.addEventListener('click', () => this.moveNext());
		this.prevBtn.addEventListener('click', () => this.movePrev());

		document.addEventListener('keydown', (e) => {
			if (e.key === 'ArrowRight') this.moveNext();
			if (e.key === 'ArrowLeft') this.movePrev();
		});

		if (this.autoplay) {
			this.autoplayTimer = setInterval(() => this.moveNext(), this.autoplayDelay);
		}

		// Touch support for mobile - jQuery 3.x has non-blocking listener issues.
		let touchStartX = 0;
		let touchEndX = 0;
		const minSwipeDistance = 30; // px
		this.track.addEventListener('touchstart', (e) => {
			if (e.touches.length === 1) {
				touchStartX = e.touches[0].clientX;
			}
		}, { passive: true });
		this.track.addEventListener('touchmove', (e) => {
			if (e.touches.length === 1) {
				touchEndX = e.touches[0].clientX;
			}
		}, { passive: true });
		this.track.addEventListener('touchend', (e) => {
			const deltaX = touchEndX - touchStartX;
			if (Math.abs(deltaX) > minSwipeDistance) {
				if (deltaX < 0) {
					this.moveNext();
				} else {
					this.movePrev();
				}
			}
			touchStartX = 0;
			touchEndX = 0;
		});
	}

	handleResize() {
		const previousVisibleSlides = this.visibleSlides;
		const newVisibleSlides = this.getVisibleSlides();
		this.updateSlideMetrics();

		if (newVisibleSlides !== previousVisibleSlides) {
			this.setupCarousel();
		} else {
			this.slides.forEach(slide => {
				slide.style.flex = `0 0 calc((100% / visibleSlides) - ${this.marginOffset}) )`;
			});
			this.updatePosition();
		}
	}
}
</script>